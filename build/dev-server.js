require('./check-versions')();

const path = require('path');
const webpack = require('webpack');
const MFS = require('memory-fs');
const clientConfig = require('./webpack.client.conf');
const serverConfig = require('./webpack.server.conf');

const readFile = (fs, file) => {
    const filepath = path.join(clientConfig.output.path, file)
    try {
        return fs.readFileSync(filepath, 'utf-8')
    } catch (error) {
        console.error(`readFile ${filepath} Error:`, error.statck)
    }
};

const hotMiddleware = (compiler, opts) => {
    const expressMiddleware = require('webpack-hot-middleware')(compiler, opts)
    return (ctx, next) => {
        const stream = new require('stream').PassThrough()
        ctx.body = stream;
        return expressMiddleware(ctx.req, {
            write: stream.write.bind(stream),
            writeHead: (state, headers) => {
                ctx.state = state;
                ctx.set(headers)
            },
        }, next)
    }
};


module.exports = function setupDevServer(app, cb) {
    let bundle;
    let clientManifest;
    let resolve;
    const readyPromise = new Promise(r => {
        resolve = r
    });
    const ready = (...args) => {
        resolve();
        cb(...args)
    };

    // modify client config to work with hot middleware
    clientConfig.entry.app = ['webpack-hot-middleware/client', clientConfig.entry.app]

    // dev middleware
    const clientCompiler = webpack(clientConfig)
    const devMiddleware = require('webpack-dev-middleware')(clientCompiler, {
        publicPath: clientConfig.output.publicPath,
        noInfo: true,
        stats: {
            colors: true,
            chunks: false
        }
    });

    app.use((ctx, next) => devMiddleware(ctx.req, {
            end: (content) => {
                ctx.body = content
            },
            setHeader: (name, value) => {
                ctx.headers[name] = value
            }
        }, next)
    );

    clientCompiler.plugin('done', (stats) => {
        stats = stats.toJson();
        stats.errors.forEach(err => console.error(err));
        stats.warnings.forEach(err => console.warn(err));
        if (stats.errors.length) return;

        clientManifest = JSON.parse(readFile(
            devMiddleware.fileSystem,
            'vue-ssr-client-manifest.json'
        ));
        if (bundle) {
            ready(bundle, {
                clientManifest
            })
        }
    });

    // hot middleware
    app.use(hotMiddleware(clientCompiler, {heartbeat: 5000}))

    // watch and update server renderer
    const serverCompiler = webpack(serverConfig);
    const mfs = new MFS();
    serverCompiler.outputFileSystem = mfs;
    serverCompiler.watch({}, (err, stats) => {
        if (err) throw err;
        stats = stats.toJson();
        stats.errors.forEach(err => console.error(err));
        stats.warnings.forEach(err => console.warn(err));
        if (stats.errors.length) return;

        // read bundle generated by vue-ssr-webpack-plugin
        // const readFile = (file) => mfs.readFileSync(path.join(serverConfig.output.path, file), 'utf-8')
        bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'));
        if (clientManifest) {
            ready(bundle, {
                clientManifest
            })
        }
    });

    return readyPromise
};
